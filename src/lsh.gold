#!/usr/bin/env ../gold
# vim: filetype=awk nospell ts=2 sw=2 sts=2  et :

@include "lib/gold.awk"
@include "lib/csv.awk"
@include "lib/o.awk"
@include "lib/ksort.awk"
@include "lib/cat.awk"
@include "data.gold"

function LshMy(my) {
  my.p       = 2
  my.start   = 5
  my.samples = 100
  my.poles   = 10
  my.trim    = 0.95
}
function  lshMain( f) { srand(1); Lsh(f) }

function Lsh(f,   data, my,a,n,poles,r,dims) {
  LshMy(my)
  Data(data)
  List(poles)
  while(csv(a,f)) 
    if(!Data0(data,a))
      Data1(data,a)
  LshPoles(my,data,poles)
  LshDump(my,data,poles)
}
function LshDump(my,data,poles,       dims,r ) { 
  print(cat(data.cols.names) "," LshNames(my)",%poles")
  for(r in data.rows) {
    LshCols(my,data,poles,r,dims)
    print(cat(data.rows[r])","cat(dims,",")","cat(dims,"-")) }
}
function LshNames(my,   j,a) {
  for(j=1; j<=my.poles; j++) a[j]= "%pole" j
  return cat(a)
}
function Pole(i,zero,one,d) {
  i.zero = zero
  i.one = one
  i.d =  d
}
function LshCols(my,d,poles,r,a,
                  p,r0,r1,d0,d1) {
  for(p in poles) {
    r0  = poles[p].zero
    r1  = poles[p].one
    d0  = DataDist(d, d.rows[r], d.rows[r0], my.p)
    d1  = DataDist(d, d.rows[r], d.rows[r1], my.p)
    a[p]= d0 < d1 }
}
function LshPoles(my,d,poles,
                  m,r0,r1,n,used) {
  n=length(d.rows)
  for(m=1; m<=my.samples; m++) {
    r0 = int(n*rand())+1
    r1 = int(n*rand())+1
    if(r0 != r1)
      if(used[r0,r1]++ == 0)  
         hassss(poles,length(poles)+1, 
                "Pole",r0,r1,
                DataDist(d, d.rows[r0], d.rows[r1], my.p)) }
  LshPolesBest(my,poles)
}
function LshPolesBest(my,poles,  hi,lo,p) {
  ksort(poles,"d")
  hi = int(length(poles)*my.trim) 
  lo = hi - my.poles
  if (lo<1) lo = 1
  for(p in poles) 
    if ((p>= hi) || (p <= lo)) 
      delete poles[p]  
}
